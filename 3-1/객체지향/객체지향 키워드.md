# 🎯 유니티 기초 핵심 요약

## 1. 게임 엔진 개념

|구분|설명|
|:--|:--|
|**정의**|게임 개발에 필요한 기능을 제공하는 소프트웨어 프레임워크|
|**주요 기능**|렌더링, 물리 엔진, 충돌 감지, 오디오, 스크립팅, UI 시스템|
|**장점**|핵심 로직/콘텐츠 개발에 집중 가능|

---

## 2. 유니티 기본 개요

|구분|설명|
|:--|:--|
|**출시**|Unity Technologies, 2005년|
|**특징**|25개 이상 플랫폼 지원, 접근성 좋음, Asset Store 존재|
|**구조**|유저코드(C#) → 엔진코어(C++) → 플랫폼별 네이티브 코드|
|**실행 방식**|C#은 Mono/.NET VM, 엔진은 C++ 최적화|

---

## 3. 유니티 핵심 개념

|항목|설명|
|:--|:--|
|**GameObject**|모든 유니티 객체의 기본 단위|
|**Transform**|모든 GameObject가 위치·회전·크기 정보 가짐|
|**Component**|기능 단위 부착 시스템 (Renderer, Collider 등)|
|**특징**|계층구조, 활성/비활성 가능|

---

## 4. C# 스크립팅 구조

|항목|설명|
|:--|:--|
|**기반 언어**|C#|
|**기본 상속**|MonoBehaviour|
|**주요 메서드**|Awake(), Start(), Update() (순서 중요)|
|**이벤트 기반**|입력 → Update → 물리 계산 → 렌더링|

---

## 5. 유니티 물리 시스템

|항목|설명|
|:--|:--|
|**엔진**|NVIDIA PhysX 기반|
|**핵심 컴포넌트**|Rigidbody, Collider, Joint|
|**충돌 감지**|Collision Event (물리 충돌), Trigger Event (영역 출입)|
|**레이캐스팅**|광선을 발사해 객체 탐지|

---

## 6. 객체지향 프로그래밍 (OOP)과 유니티

|항목|유니티에서의 구현 방식|
|:--|:--|
|**캡슐화**|private 변수 + public 메서드 사용|
|**상속**|MonoBehaviour 상속|
|**다형성**|인터페이스/가상 메서드로 다양성 지원|
|**컴포넌트 패턴**|단일 상속 한계 극복 (컴포넌트 조합)|
|**의존성 주입**|컴포넌트 간 참조 연결|
|**관찰자 패턴**|이벤트와 델리게이트 활용|

---

# ✨ 한 줄 요약

> 유니티는 **GameObject + Component 시스템**을 기반으로  
> **OOP 원칙(캡슐화, 상속, 다형성)**을 자연스럽게 실천하는 **게임 엔진**이다.

---


# 객체지향 필요한 이유
- 문제점
	- 절차적 프로그래밍 한계
	- 데이터 관리 어려움
	- 코드 관리가 어려움
- ==캡슐화==를 제공해 객체지향은 데이터+기능을 묶어주기 떄문
- ==재사용성==을 제공하여 유지보수성, 재사용성, 확장성을 확보해주기 때문
## 캡슐화
- 데이터(변수)와 기능(메서드)를 하나의 단위로 묶는 것
- 데이터 보호 및 무결성 유지
- 구현 세부사항 숨기기
- 유지 보수 향상

# 클래스 구조
- 멤버변수 : 객체의 상태 저장소 (private가 기본)
- 생성자 : 객체 초기 세팅 (base로 부모 호출가능, virtual 필요 없음)
- 메서드 : 객체의 기능/행동 (virtual, override로 재정의 가능)

# 캡슐화와 접근 제어
- public : 클래스 외부/내부 즉, 어디서나 접근가능
- private : 클래스 내부에서만 접근 가능
- protected : 상속받은 클래스에서만 접근가능
- 단일 책임 원칙(SRP) : 클래스마다 하나의 책임을 가짐

# 메모리 구조
- Stack 
	- 지역변수, 메게변수
	- 빠르고 자동 관리함
	- 함수가 실행되는 동안이라 짧다
- Heap :
	- 동적 메모리 할당, 멤버변수
	- 포인터 탐색과 조작이 필요해서 느리다
	- 시스템 메모리 한도까지 사용해 크다


# 메서드 / 프로퍼티
- 일단 멤버변수 : 데이터 저장
- 프로퍼티 : 상태관리 + 무결성 검사(get/set)
	- get에서 변수 호출 가능
	- set에서 변수 제어 가능 


# 상속 (is-a 관계)
- 부모 클래스 기능/속성 상속
- virtual : 부모 메소드 변경 허용
- override : 자식 메서드 재정의
- base : 부모 메서드 호출

# 생성자 상속
- 생성자는 virtual, override 안씀
- base로 부모 생성자 호출 → 부모 초기화 → 자식 초기화

# 상속 vs 컴포지션
- 상속
	- is-a (A는 B이다)
	- 강한 결합
	- 공통 기능 공유에 적합
	
- 컴포지션
	-  has-a (A는 B를 가진다)
	- 느슨한 결합(변경 영향 적음)
	- 유연성, 교체성 필요할 때 적합

- 상속 : 명확한 관계가 있을때 (ex. Sword는 Weapon)
- 컴표지션 : 유연성, 조합, 변경이 자주 필요할때 (ex. Player는 Weapon을 가짐)

# 추상 클래스와 메서드
- 추상 클래스 : 설계만, 미완성 명시
- 추상 메서드 : 껍데기만 제공, 자식이 반드시 구현
- virtual: 부모 클래스에서 메서드만 선언 → 필요하면 자식이 재정의
	- 부모클래스에서 메서드만 선언하여 기본 구현 제공만 해주기때문에 미완성임
- "공격하는 방법"처럼 다양한 종류 같은건 추상 메서드로 한다


# 인터페이스
- interface : 규칙 통일
- "공격 당할수 있음"처럼 공통 규칙은 인터페이스로 강제
- 메서드만 선언 → 구현은 각자 다르게
- 덕분에 코드가 간결 + 일관성 유지됨


# 확장된 is-a
- 리스코프 치환 원칙(LSP)
	- 자식 클래스가 부모 기대를 깨지 않고 대체 가능해야 한다

- 부모 행동 기약을 자식이 어기면 안됨
	부모는 새라고 정의 했고 날수 있다했는데 자식은 팽귄을 해서 못난다고 할 경우

# 흐름 정리

- **캡슐화**: 데이터 숨기기 + 무결성 유지
    
- **상속**: 공통기능 공유 (is-a)
    
- **컴포지션**: 조합과









