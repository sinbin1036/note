~~책 데이터베이스 개론(한빛아카데미_김연희)~~
조대수 교수님 - 010-4565-2106(문자로

?는 다 GPT물어보기
정의만 외우지말고 왜 그런지(WHY)접근법으로 공부해야 함
[[DB 키워드]]]
# 1장 데이터베이스의 기본 개념
Preview
	==이게 1장 그자체== 
	![[Pasted image 20250310113827.png]]
	DB에서의 저 공유, 통합, 저장, 운영이 ==무슨 뜻으로 쓰이나가 관점==
	저거 하나하나가 무엇을 뜻하지만 알면 1장은 끝(?)

## DB의 필요성
###### 데이터(data)
현실세계에서 단순히 관찰하거나 측정하여 수집한 사실(T)이나 값(V)
	-> 겨울엔 아우터중 패딩이 잘 팔린다란 데이터?
	->여름엔 썬크림이 더 잘팔린다는 데이터?
###### 정보(Information)
의사 결정에 유용하게 활용할 수 있도록 데이터를 처리한 결과물 
	->많은 데이터중 일정하게 일어나는 데이터를 정리해서 하나의 함수로 만드는것?
	->의사결정을 도와주는 것
![[Pasted image 20250311112955.png]]
	정보 처리
		데이터에서 정보를 추출하는 과정 또는 방법
			*데이터(Input)를 처리해서 정보(Output)으로 나온다*
			*->데이터를 가공해서 정보로 처리한다 (공존관계)*

###### DSS MS
MS
	기업의 경영관리에 필요한 의사 결정용 정보 시스템
DDS
	복합적이고 광범위한 의사결정을 위해 사용되는 정보 시스템 의사 결정 지원 시스템

----
## 데이터 베이스의 정의와 특징

### 정의
특정 조직의 여러 사용자가 ==공유==하여 사용할수 있도록 ==통합==해서 ==저장==한 ==운영== 데이터 집합
![[Pasted image 20250317102928.png]]
##### 공유 데이터
- 특정 조직의 여러 사용자가 함께 소유하고 이용할 수 있는 공용 데이터
##### 통합 데이터 *9분*
- 데이터의 중복을 최소화하고 통제가 가능한 중복만 허용하는 데이터
	 ==데이터 중복성==
		-> DB는 데이터 중복성을 허용하지 않음
		
>  trade-off?
>   **이거 셤에 나올듯**
> 데이터가 중복이 좋냐 안좋냐는 유도리의 문제 정답은 없음
	장점
		검색 측면에서는 데이터 중복이 장점이 된다.
	단점
		데이터를 업데이트 할때 속도가 느리다(좀 비효울적이다)
		[^2]==일관성==을 유지하는데 비용이 너무 든다

[^2]: ==DB에서 생명은 일관성==이다. (은행이 서로 다른 지점에서 내가 들고 있는 돈이 다르면 안되기 때문과 같은 선상)

##### 저장 데이터
- 컴퓨터가 접근할수 있는 매체에 저장된 데이터
###### 운영 데이터
- 조직의 주요 기능을 수행하기 위해 지속적으로 꼭 필요한 데이터

### 특징

##### 실시간 접근 가능
- 사용자의 데이터 요구에 ==실시간으로 응답==할줄 알아야 한다
##### 계속 변화
- 데이터의 계속적인 삽입, 삭제,  수정을 통해 현재의 ==정확한 데이터를 유지==
##### 동시 공유 가능
- 서로 다른 데이터의 동시 사용뿐만 아니라 ==같은 데이터를 동시에 사용도 **모두 지원한다**==
##### 내용으로 참조 가능
- 데이터가 저장된 주소나 위치가 아닌 데이터 내용, 즉 ==값으로 참조 가능==하다
	->재고량이 1000개가 넘는 제품 이름을 검색하시오. 가능하다


---

## 데이터 과학 시대의 데이터

### 형태에 따른 데이터 분류

![[Pasted image 20250317102958.png]]
#### 정형 데이터
- 구조화된 데이터, 즉 미리 정해진 구조에 따라 데이터를 저장하는것
- 데이터 구조에 대한 설명과 데이터 내용은 별도로 유지된다

Ex) 엑셀 스프레드시트, 관계 데이터 베이스 테이블
![[Pasted image 20250317104128.png]]
##### 메타 데이터
데이터를 설명하는 데이터
	![[Pasted image 20250317103724.png]]
	-> 빠르다 택배는 배송업체를 설명하는 데이터인것 
		*배송 업체 = 빠르다 택배 가 아닌것*
##### 스키마
미리 정해진 데이터 구조를 뜻함
	![[Pasted image 20250317104716.png]]
	DB를 보통 설계하는 사람을 스키마를 설계하는 사람이라고 할수 있다
#### 반정형 데이터
- 구조에 따라 따라 저장된 데이터이지만 데이터 내용안에 구조에 대한 설명이 함께 존재함
Ex) HTML, XML, JSON 문서나 웹 로그, 센서 데이터 등
![[Pasted image 20250317104534.png]]

#### 비정형 데이터
- 정해진 구조가 없이 저장된 데이터

Ex) 소셜데이터의 텍스트, 영상, 이미지
	-> 워드나 PDF 문서와 같은 멀티미디어 데이터
![[Pasted image 20250317104911.png]]

### 특성에 따른 데이터 분류
![[Pasted image 20250317103428.png]]
#### 범주형 데이터
- 종류를 나타내는 데이터
	명목형 데이터
		서열이 없는 데이터
		ex) 성별, 혈액형, MBTI, 거주
		
	순서형 데이터
		서열이 있는 데이터
		ex)학년, 학점, 회원 등급

#### 수치형 데이터
- 크기 비교연산이 가능한 데이터
	이산형 데이터
		갯수를 셀수 있는 데이터
		ex) 고객수, 판매량, 합격자수
		
	연속형 데이터
		측정을 힐 수 있는 데이터
		ex)키, 몸무게, 온도,점수

---
---
---

# 2장 데이터베이스 관리 시스템

![[Pasted image 20250317112223.png]]
DBMS 공부한다는데..?
	-> 왜 DBMS를 쓰는거에 대한 이유를 공부하는게 중요할듯
	==중복, 종속== 단어가 중요함 **(진짜 중요한듯 셤에 나온대)**
	파일시스템
		단점
			중복 -(보완?)> 최소화 
			종속 -(보완?)> 독립
		**(중복, 종속에 대한 문제점과 단점에 대해 명확히 알아야한다)**
		장점
			저비용

## 데이터베이스 관리 시스템의 등장 배경
데이터와 프로그램의 종속관계를 잘 이해해야한다
종속(전번 전화) ==직접== -> 독립(카톡 전화) ==레이어, 매핑==
	독립의 구현 방법
		**레이어, 매핑 (이거 이해해야할듯 무조건)**



## 데이터베이스 관리 시스템의 정의


DBMS에서 SQL을써서 스키마를 디자인을 하는건가?
	일단 DBMS단계에선 스키마를 디자인 하는건 맞지만 그것만 하는것이 아님

*정리 따로 해야함*
## 데이터베이스 관리 시스템의 장.단점

파일시스템보다 DBMS가 더 보안성이 높다?
	근데 DBMS는 한번 뚫리면 둠스데이 찍음
	파일시스템은 보안성은 낮지만

*정리 따로 해야함*
## 데이터베이스 관리 시스템의 발전 과정


### 1세대
network DB
- 그래프구조
계층 DB
- 트리구조
![[Pasted image 20250324104832.png]]
## 2세대
관계 DB
![[Pasted image 20250324104845.png]]
표(테이블)을 이용하여 관계 DB를 사용한다 (하나의 열당 튜플이라 한다)
	*여기서부터 스키마가 등장한건가?* (GPT)
장점
- DB가 단순하고 이해하기 쉬운 구조로 구성
관계 DBMS 종류
- 오라클
- MS SQL 서버
- MYSQL 
- 등
## 3세대
객체지향 DBMS
	객체지향에 대해 뭔지 제대로 이해해야할듯 

*class 이해하고 활용하고 객체지향으로 전환하기엔 너무 비용이 많이 듦*

객체관계 DBMS
- 객체지향 DMBS 보완점
- 객체도 쓰고 관계도 쓰는 DBMS? 
#### 4세대

배경
- SNS가 인기가 불타면서 비정형 데이터가 다량으로 생산됨
- 2세대는 빠른속도로 증가하는 데이터를 처리하는데 비효율임
- 3세대는 비용이 말이 안됨

NoSQL
- 비정형 데이터를 처리하는데 뛰어남
- 안정성과 일관성 유지를 위해 복잡한 기능 포기함
- 데이터 구조를 미리 정해두지 않은 유연성을 가짐
- 몽고디비, HBase, 등

NewSQL
- 관계 DBMS + NoSQL의 유연성
- 더 빠르게 데이터 처리 가능

---
---
---
# 3장 데이터베이스 시스템
DB에 있어서 3단계 구조를 익히는게 관건
![[Pasted image 20250324113224.png]]
## 데이터베이스 시스템의 정의
데이터베이스 시스템
- 데이터베이스에 데이터를 저장하고, 이를 관리하여 필요한 정보를 생성해주는 시스템
- ![[Pasted image 20250324113541.png]]

## 데이터베이스의 구조

### 스키마
스키마
- 데이터베이스에 저장되는 데이터 구조
인스턴스
- 스키마에 따라 데이터베이스에 실제로 저장된값

### 3단계 데이터베이스의 구조
정의
	세부적으로 바라보는 구조가 통상적으로 3단계로 나뉘기 때문에 
	외부, 개념, 내부 단계로 3가지로 나뉜다

> 예시
> 	내부 단계
> 		건설업체의 관점
> 		철근이라던지 콘크리트 배합이 잘 맞고 무개중심이 잘맞았나?
> 	관리 단계
> 		관리인 관점
> 	외부 단계
> 		집주인 관점


#### 외부 단계

#### 개념 단계

#### 내부 단계


### ==데이터 독립성==
하위 스키마를 변경하더라도 상위 스키마가 영향받지 않는 특성
	데이터 독립성을 구현하기 위해서는 ==레이어, 매핑==이 필연적으로 중요하다

![[Pasted image 20250325112811.png]]

논리적 데이터 독립성
- 개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않는다.
- 외부/개념사상만 정확하게 수정해주면 된다

물리적 데이터 독립성
- 내부 스키마가 변경되어도 개념 스키마는 영향을 받지 않는다.
- 개념/내부 사상만 정확하게 수정해주면 된다

> 그러면 단계로 레이어를 가지고 단계마다 서로 충돌하지 않고 조율해주는게 매핑?
> 그래서 매핑과 레이어는 한몸이여서 독립성에서 중요하다 한건가?
> 
> 레이어를 가진다는게 메모리 계층이 지역성을 띄는거랑 비슷한 개념이고
> 메핑은 데이터버스 같은 개념인가?  DMA같은 느낌?

### 데이터 사전
시스템 카탈로그라고도 한다 (데이터 사전과 비슷한말)
스키마, 사상 정보, 다양한 제약조건등을 저장하는 곳 (이게 어떤 정보인가?)
데이터 사전도 데이터를 저장하는 DB일종이라 시스템 DB라고도 함

## 데이터베이스 사용자

----
----
ㅈ됨 수업 뭔지 안들음
123 4에서 ER모델 설명한다고 잠깐 8로 간듯 

----

# 8장 데이터베이스 설계  
(모델링을 설명을 하기전에 잠깐 온것)
모델링을 도와주는 도구가 모델이다
ER모델
관계 모델

컴퓨터를 바꾸는게 개념을 잡는 단계를 넘어서 
	==9분대 중요한 말인듯==

엔티티(entity)
	객체

관계 (Relationship)

그럼 DB설계 어찌보면 구조체 느낌인가?

ER 모델
- E(entity) R(Relationship)
- 세계를


#  4장 데이터 모델링

==ER-다이어그램을 완벽히 이해할줄 알아야 하는것==
==이거 ㅅㅂ 내가 직접 ER다이어그램 그리게 할꺼 같다==
진짜 무조건 그리게 할꺼 같다

우리는 관계형 DB를 쓴다

## 개체-관계 모델

###  개체
 개체의 중요한 성질
- 구별
	개체는 ==구별==이 무조건 되어야한다
- 저장
	==저장==할만한 정보인지 판단해야한다
**개체는 구별과 저장이 중요하다**
![[Pasted image 20250401113754.png]]
##### 개체 타입
개체를 고유한 이름과 속성들로 정의

##### 개체 인스터스
개체를 구성하고 있는 속성이 실제 값을 가짐으로써 실체화된 개체

##### 개체 집합
특정 개체 타입에 대한 개체 인스턴스들을 모아둔것
	개체 인스턴스 모아둔것

### 속성
개체나 관계가 가지고 있는 고유한 특성

![[Pasted image 20250401113719.png]]

#####  단일 값 속성과 다중 값 속성
단일값 속성
- 값을 하나만 가질수 있는 속성
- 예) 고객 개체의 이름
다중값 속성
- 값을 여러개 가질수 있는 속성
- 예) 고객 개체의 연락처 속성
- ==ER 다이어그램에서 이중타원으로 표현함==
![[Pasted image 20250401114230.png]]

##### 단순속성과 복합 속성
단순 속성
- 의미를 더는 분해 할수 없는 속성
복합 속성
- 의미를 분해 할수 있는 속성
![[Pasted image 20250401114402.png]]

##### 유도 속성
==중복과 설명관계가 있다==
- 기존의 다른 속성 값에서 유도 되어 결정되는 속성
- 값이 별도로 저장되진 않음
- ==ER 다이어그램에서 점선 타원으로 표현
- 설명과 이해가 더 필요할듯 (도와줘 GPT몬)
![[Pasted image 20250401114747.png]]

##### 널 속성
널 값이 허용되는 속성

넓 값
- 아직 결정되지 않았거나 모르는값 즉, 존재하지 않는 값
- 공백이나 0값과 다름
	공백은 쓰레기값이 들어갈수도 있고 한데 ==모르는 값==이라고 그냥 지정한 것
	0도 값이라 널과는 다른 값임

##### 키 속성
개체 집합에 존재하는 각 개체 인스턴스들을 ==식별==하는데 사용
- 모든 개체 인스턴스 키 속성 값은 다름
- ==ER-다이어그램에서 밑줄로 표현==
- 고객아이디가 키 속성 되긴한다
- ![[Pasted image 20250407101121.png]]


##### 관계
개체와 개체가 맺고 있는 의미 있는 연관성

> ER다이어그램할때 R은 Relatioship이고
> 관계형DB할때(RDB) R은 Relation이다 

- 개체 집합들 사이의 대응관계 즉 ==매핑==을 의미함

##### 관계 유형
 관계에 참여하는 개체 타입의 수 기준

- 이항 관계

- 삼항 관계

- 순환 관계
	군대 직급체제가 예시인가? (분대 소대 중대 대대 사단 여단?)

==매핑 카디널리티==
- DB설계 과정에서 중요하게 활용되는 ==관계 분류 기준==
- 뜻을 풀어쓰면 ==매핑의 원소의 수==이다
- 한 사람이 책을 n개 사는 느낌(한 고객이 책을 n개를 살수 있냐?가 중요)
- 고객이 n일수도 있고 책이 n일수도 있다는 것

- 일대일(1:1) 관계
	![[Pasted image 20250407103905.png]]

- 일대다(1:n) 관계
	![[Pasted image 20250407103910.png]]
- 다대다(n:n) 관계
	![[Pasted image 20250407103917.png]]

근데 장우성같은 부서가 없는 사원은? 부서에 사원이 없는 부서는?

##### 관계 참여 특성
###### 필수적 참여
- 모든개체 인스턴스가 관계에 반드시 참여해야한다는 것을 의미
- 위에 부서가 없는 사원은 있을수가 없는 거랑 같은 선상
- 1이 최소 카디널이라고도 한다(?)
- ==ER-다이어그램에서 이중선으로 표현==
###### 선택적 참여
- 개체 인스턴스중 일부만 관계에 참여해도 되는 것을 의미
- 책 개체가 고객 개체와의 구매 관계에 선택적으로 참여 가능
- 고객이 구매하지 않은 책이 있을수도 있다는 것
- 0이 최소 카디널이라고도 한다(?)

![[Pasted image 20250407104939.png]]
이야 책 강매 레전드네

##### 관계 종속성
![[Pasted image 20250407112531.png]]
###### 약한 개체
- 혼자서는 존재 할수 없는 개체
- 강한개체 의존하는 개체
- 강한개체가 존재해야 하는 개체
###### 강한 개체
- 다른 개체의 존재 여부에 의존적인 개체
- 오너(owner) 개체라고도 함

###### 특징
- 약한개체는 강한개체와의 필수적으로 참여 해야한다 
- 약한개체는 이중으로 표현한다
- 위에 사진보면 부양가족은 약한개체로 이중사각형 (근데 부양 관계는 왜..?)

###### 식별관계 
- 오너객체의 ==키 속성==을 포함해야만 식별가능할때
	개체와 개체를 관계로 매핑할때 하나라도 약한개체가 있으면 그 관계는 식벽관계가 된다?
	- 강한 객체의 키를 불러와야만 식별이 가능하다라는 것
> ✅ 부양가족은 **직원이 있어야 존재할 수 있는 약한 개체**  
> ✅ 직원은 **강한 개체(Owner)**  
> ✅ 그래서 부양가족은 **직원의 키를 빌려서 자기 키를 만든다**  
> 👉 이렇게 해야 **식별관계**가 된다!

> - 직원 ID: `emp_id`
> - 부양가족에는 **자기만의 키가 없음**
> - 그래서 PK를 `emp_id + 가족이름`으로 만듦
> 👉 `부양가족.emp_id`는 **직원의 PK를 포함**  
> 👉 이 관계는 **식별 관계**

젤 어려운 이론임 이것만 이해하면 끝


## 논리적 데이터 모델
이건 뭐 스윽 훑어 보기만 하면될듯
본격적으로 하는건 논리적 설계 ==스키마==를 설계 할꺼라
트리니 그래프니 뭐니는 안할듯

# 5장 관계 데이터 모델

## 관계 데이터 모델의 개념념
##### 릴레이션
하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것?


##### ==도메인==
- 하나의 속성이 가질수 있는 모든 값의 집합
- 타입처럼 보일순 있지만 타입은 아니다

가능한 값을 일일이 나열하기 어려운 경우가 대부분이라
- 일반 적으로 속성의 특성을 고려한 데이터타입으로 정의한다

무결성 검사를 도메인이 해버리기 때문에 내가 할필요없이 DB가 해준다

##### 널 값

##### 차수

#### 릴레이션과 데이터 베이스의 구성

##### 릴레이션 스키마
- 릴레이션 논리적 구조
- 릴레이션의 이름과 릴레이션에 포함된 모든 속성의 이름으로 정의

##### 릴레이션 인스턴스
- 어느한 시점에 릴레이션에 존재하는 튜플들의 집합


#### 릴레이션의 특징
- 튜플의 유일성
	하나의 릴레이션에는 동일한 튜플이 존재 할수 없다
- 투플의 무순서
	하나의 릴레이션에서 투플 사이의 순서는 무의미하다
- 속성의 무순서
	하나의 릴레이션에서 속성 사의의 순서는 무의미하다
- 속성의 원자성
	속성 값으로 원자 값만 사용할수 있다
	ER다이어그램의 다중값 속성은 릴레이션 속성변화에 허용하지 않는다

#### 키의 종류
###### 개념
- 릴레이션에 포함된 튜플들을 유일하게 구별해주는 역할
- 속성 또는 속성들의 집합을 의미하긴 함

##### 종류
###### 슈퍼키
개념
- 슈퍼키는 ==유일성==의 특성을 만족하는 속성또는 속성들의 집합
	유일한 키인가? -> 고객 아이디가 슈퍼키에 해당
- 키 값이 같은 투플은 존재 할수 없다
단점
	튜플 하나를 유일하게 구별하기 위해 불필요한 속성값(여러개의 속성값)까지 확인하는 비효율작업이 요구되는 경우가 있다

###### 후보키
개념
- 후보키는 유일성과 ==최소성==을 만족하는 속성또는 속성들의 집합
	최소성이란?
		꼭 필요한 최소한의 속성들로만 키를 구성하는 특성
	
	
- 슈퍼키처럼 구별하기 위해 불필요한 속성값(여러개의 속성값)까지 확인하는 비효율작업을 하지 않는다

###### ==기본키==
개념
- 여러 후보키 중 반드시 선택해야 하는 키가 기본키이다
	고객아이디가 기본키(Primary Key)즉 PK이라 한다
	![[Pasted image 20250414104026.png]]
	기본키(PK)를 선택할때 고려해야 할점 (녹음 다시 듣기)
	- 널 값을 가질 수 있는 속성이 포함된 후보키는 기본키로 부적합하다
	- 값이 자주 변경될수 있는 속성이 포한된 후보키는 기본키로 부적합하다
	- 단순한 후보키를 기본키로 선택한다

###### 대체키
개념
- 나머지 남은 키(이메일,전번,주민등록번호) 대체키


###### ==외래키==
개념 (녹음 다시 듣기)
- 어떤 릴레이션에 소속된 속성또는 속성 집합이 다른 릴레이션의 기본키가 되는것
	다른 릴레이션 기본키를 그대로 ==참조==하는 속성의 집합
	키가 서로 공유 된것이 아니라 다른 테이블의 데이터를 ==참조하는 링크 역할==을 해줌 

![[Pasted image 20250414111012.png]]
고객 릴레이션은 ==참조 되는 릴레이션==, 주문 릴레이션은 ==참조 하는 릴레이션==이다
참조하는 릴레이션은
- FK 속성값 즉, 참조되는 PK에 값이 있는지 없는지 확인을 한다. 없을경우 삽입 거절이 된다
즉 다시말해, 참조되는 키의 값이 있어야 삽입이 되므로 무결성을 보장해준다

참조되는 릴레이션 키가 사라질경우(==참조 무결성 제약조건== 위반시)
- 거절
	참조 되는 PK 삭제시 -> 오류 발생
	주문에 apple 남아 있을경우 삭제 거절됨
	삽입을 거절한다
	중요한 데이터(ex. 고객, 회원)은 거절이 일반적
- 연쇄
	참조되는 릴레이션에 기본키 속성이 하나 사라질경우  참조 받는 릴레이션도 함께 날린다
- null 처리
	연쇄를 하지 않고 null값으로 처리한다 (데이터를 살리기 위함)
- 별도 값으로 설정
	삭제된 값 즉,어떤 값으로 자동 변경

**참조되는 릴레이션(PK)이 사라지면, 참조하고 있던 FK 쪽은 기본적으로 오류 발생**  
→ 다만, **CASCADE / SET NULL / SET DEFAULT** 등으로 동작 방식을 미리 지정할 수 있음

==참조 무결성 제약조건== 
	FK는 반드시 참조하는 PK의 값을 가져야 한다
	.
	참조되는 릴레이션은 마음대로 삭제가 어렵고
	참조하는 릴레이션은 맘대로 수정을 못한다
	.
	그러면 참조 받는 릴레이션(FK보유)은 참조되는 릴레이션(PK보유)에 종속적이다
	이 때문에 **PK는 삭제가 제한되고, FK는 값이 제한**되는 구조가 된다.
제약이 어디에 생기는가가 중요한 관점

![[Pasted image 20250414114319.png]]
이런 경우도 있다 알아서 정리 하자


![[Pasted image 20250414114345.png]]
이런 경우도 또 있다 알아서 정리


외래키(FK)와 기본키(PK)는 무결성과 관련된 이론이다

## 관계 데이터 모델의 제약

#### 무결성 제약조건
개념

종류
개체 무결성 제약조건
	기본키를 구성하는 모든 속성은 null 값을 가질수 없다

참조 무결성 제약조건
	외래키는 참조할수 없는 값을 가질수 없다

<<<<<<< HEAD

외래키는 참조니깐 어찌보면 클래스 개념?
	참조되는 릴레이션이 부모클래스이고, 
	참조받는 릴레이션은 자식클래스?

# 6장 관계 데이터 연산
관계 데이터 연산에서 괸계 대수만 공부를 할거 같음
예제랑 뒤에 문제를 많이 풀면 될듯
==6장에서 조인이 가장 중요한 개념==

## 관계 대수
관계 대수 연산자 종류
![[Pasted image 20250421101748.png]]
### 일반 집합 연산자
#### 특성
- 피연산자 2개가 필요, 2개의 릴레이션 대상으로 연산수행
- 각 속성의 갯수와 도메인이 같아야 한다 즉, 
  2개의 릴레이션이 ==합병가능==해야 한다

#### 합집합
- 개념
	합병 가능한 두 릴레이션 R,S의 합집합 : R∪S

- 특징 
	교환과 결합의 특징이 있다.

![[Pasted image 20250421103207.png]]
#### 교집합
- 개념
	합병 가능한 두 릴레이션 R,S의 교집합 : R∩S
	
- 특징 
	2개의 릴레이션이 ==합병가능==해야 한다
#### 차집합
- 개념
	합병 가능한 두 릴레이션 R,S의 차집합 : R-S
	
- 특징 
	2개의 릴레이션이 ==합병가능==해야 한다
#### 카티션 프로덕트
- 개념
	옆으로 합친다음 새로운 튜플을 반환

- 특징 
	가능한 모든 경우의 수를 합친다

	
### 순수 관계 연산자

#### 셀렉트(select)
- 릴레이션 R에서 조건을 만족하는 투플을 반환
	내가 찾고 싶은 투플을 찾겠다..?
![[Pasted image 20250421103543.png]]
==기말 6-2처럼 낸다==

- 예시  *38분대 설명*
동서대 학생 10000명에서 SW + 여학생 찾기

#### 프로젝트 
- 릴레이션에서 선택한 속성의 값으로 릴레이션 구성



![[Pasted image 20250421103713.png]]


#### ==조인==
조인 속성을 이용해 두 릴레이션을 조합하여 결과 릴레이션을 구성
공통된 속성을 찾아 나열한다 ==(젤 중요하고 어렵네)...==
조인의 필요성(11분)

- 카디션 프로덱트와 조인 차이점
	조인은 카디션 프로덱트와 다르게 ==공통된 속성==이 필요하다
##### 종류
###### 동등 조인
속성 값이 같은 걸 조건으로 잡는 거지만 꼭 PK-FK가 아닐수도 있다


###### 세타 조인 (2분인가 3분)

`=` 연산을 가장많이 사용한다

###### 자연 조인
동등 조인의 결과 릴레이션에서 조인 속성이 한 번만 나타나게 하는 연산
똑같은 조인이 있으면 날려달라..?


공통된 속성을 찾는다면 서로 릴레이션 간에 PK와 FK를 찾는건가?
조인은 종류가 많기 때문에 FK도 조인의 종류 한가지 인거다?

![[Pasted image 20250421105640.png]]

###### 디비전
릴레이션2의 모든 투플과 관련이 있는 릴레이션1의 투플로 결과 릴레 이션을 구성

###### 세미조인
중복을 제거하고 필요한 정보만 조인한다..?

예시)
	주문한 고객만 뽑아오는 방법

###### 외부 조인
개념
	자연 조인 연산에서 제외되는 투플도 결과 릴레이션에 포함시키는 조인
	결과 릴레이션에서 속성 값이 없는 경우는 널 값으로 처리


- 왼쪽 외부조인
	왼쪽에 있는 릴레이션1에 존재하는 모든 투플을 결과 릴레이션에 포함
	
- 오른쪽 외부조인
	오른쪽에 있는 릴레이션2에 존재하는 모든 투플을 결과 릴레이션에 포함시킴
	
- 완전 외부조인
	두 릴레이션에 있는 모든 투플을 결과 릴레이션에 포함시킴

조인...
![[Pasted image 20250428103045.png]]

# 7장 데이터베이스 언어 SQL
기말은 결과를 그려봐라...?
무한 예제 뺑뺑이 이게 정답
먼저 
1. 정리 
2. 실습
3. 안보고 실습
4. 실습 활용

## SQL 소개
SQL은 표준이다



![[Pasted image 20250428104142.png]]
이거 to_date를 해야 날짜를 파악할수 있다

DB는 절차적 언어

==WHERE 이랑 GROUP BY 햇갈리지 말기==
WHERE :  튜플끼리 비교
GROUP BY : 그룹별로 검색하기 위할때

조인이 젤 햇갈리고 어렵다


## 뷰
view = (virtual) table = 가상 테이블

virtual : 없는데 있는것처럼..

기말고사 1번
==실제 테이블로 만들고 뷰라는 왜 가상의 테이블이 필요한가?==
-> 중복에 대한 문제가 생기기 때문


질의가 있을때마다 만든다?
필요할때 만들었다가 쓰고난 다음 사라진다

뷰는 중복문제는 없애지만, 검색시간이 느려진다
->질의가 있을때마다 일일이 만들기 때문인가?

뷰는 C++ 동적메모리할당인가? -> 아님
>프로그램이 실행 중에 메모리를 필요한 만큼 만들어서 쓰는 방식

서로 겉모습은 비슷하더라도 속은 아예다름
임시변수가 맞는 말일수도

종속성의 문제를 해결해준다 뷰는?

뷰가 레이어고 셀렉트가 메핑이 된다?

예제 55.
with check option = 생성한 뷰에 삽입이나 수정 연산을 할대 select문에서 제시한 뷰의 정의 조건 위반시 ==거절(제약조건)==을 하겠다는 의미

table vs view 왜 뷰를 쓰는가?
-> 중복문제로 인한 view 사용

view 장점
-> 보안, 질의 효과적 관리

table vs view 다른점
->변경이 불가능한 view

뷰 수정이 안되는 경우
- 집계함수 사용할 경우
- PK를 포함하지 않은 뷰
- NOT NULL 속성을 포함하지 않은 뷰
- 조인 : ?
- DISTINCT : 중복을 날려 버렸기 때문..?

뷰 삭제할때는 drop view 이름


## 삽입 SQL

EXEC가 뭐지?

하나만 고민하면됨

셀렉트 할경우 변수는 한개 인데 여러개의 튜플값이 온다?
이 미스매칭을 어케 해결하냐

-> 커서삽입 SQL을 사용한다

FETCH가 한줄을 가져온다는거?

---
---
# 8장 데이터베이스 설계

## 설계 과정 단계
1단계  : 요구 사항 분석
- 데이터베이스의 용도 파악
- 요구사항 명세서
2단계  : 개념적 설계
- DBMS에 독립적인 개념적 구조 설계
- 결과물 :  E-R 다이어그램
3단계  : 논리적 설계
- DBMS에 적합한 논리적 구조 설계
- 결과물 :  릴레이션 스키마
4단계  : 물리적 설계
5단계  : 구현

%% 8장은 빨리 지나감 복습한다 느낌으로다가 %%

---
---
#  9장
DB에서 정규화는 설계돤 테이블을 정제하는 작업(?) 
- 중복 제거, 이상 방지, 무결성 유지
- 테이블을 구조적으로 쪼개는 설계 방법

## 정규화 개념과 이상현상
### 정규화
DB의 **이상현상을 제거**하면서 DB를 올바르게 설계해 나가는것

### 이상현상
**정규화되지 않은 릴레이션에서 발생하는 데이터 불일치·불편** 문제

#### 종류
##### 삽입 이상
![[Pasted image 20250526104212.png]]
###### 상황
새로운 고객 **melon**이 회원가입만 했고, 아직 이벤트에 **참여하지 않음**
###### 문제
- 이벤트 참여 정보가 없는데도, 이 테이블은 구조상 "이벤트번호"와 "당첨여부" 칼럼이 **필수로 존재**
- 불필요한 **NULL**을 넣어야만 고객정보를 등록할 수 있음
###### 정리
**삽입 이상**은 **일부 정보만 저장하고 싶은데, 테이블 구조상 불필요한 NULL 또는 가짜 데이터를 함께 넣어야 하는 문제**

##### 갱신 이상
![[Pasted image 20250526104452.png]]
###### 상황
고객 **apple**의 등급이 **gold → platinum**으로 바뀜
###### 문제
- - apple은 이벤트 3개(E001, E005, E010)에 참여했기 때문에, **총 3행에 동일한 고객정보가 중복 저장**
- 만약 1~2행만 등급을 업데이트하면, 나머지 행은 여전히 gold로 남아 **불일치 발생**
###### 정리
**갱신 이상**은 **중복 저장된 동일 정보 중 일부만 수정되면서 데이터 불일치가 발생하는 문제**

##### 삭제 이상
![[Pasted image 20250526104527.png]]
###### 상황
고객 **orange**가 참여한 이벤트(E004)를 **삭제**해야 함
###### 문제
- 이 테이블 구조에서는 ‘이벤트 참여’ 정보와 ‘고객 정보’가 하나의 행에 같이 저장되어 있음
- 이 행을 삭제하면 **고객 정보 자체도 함께 날아감**
###### 정리
**삭제 이상**은 **특정 정보만 지우고 싶은데, 함께 저장된 다른 중요한 정보까지 같이 삭제되어 손실이 발생하는 문제**

| 이상현상  | 정의                                   | 이 테이블에서의 사례 |
| ----- | ------------------------------------ | ----------- |
| 삽입 이상 | 일부 정보만 넣고 싶은데 NULL 또는 가짜 값 강제로 넣어야 함 | melon 고객    |
| 갱신 이상 | 중복된 정보 일부만 수정되면 불일치 발생               | apple 등급 수정 |
| 삭제 이상 | 이벤트만 삭제해도 고객 정보까지 손실됨                | orange 행 삭제 |

### 정규화 필요성

*정리 안해서 해야함*

---
## 함수 종속

### X → Y
#### 개념
어떤 릴레이션 R에서 속성 집합 X와 Y가 있을 때,  **X의 값이 같으면 항상 Y의 값도 같다**면  
`X → Y` 라고 하고,  "Y는 X에 함수적으로 종속된다"고 말한다

X: **결정자 (determinant)** : 기준이 되는 속성
Y: **종속자 (dependent)** : X가 고정되면 자동으로 고정되는 속성
	-> 하나의 X값이 항상 **오직 하나의 Y값**을 결정해야 함
	-> **릴레이션 내 모든 투플에 대해 성립**해야 함
그럼 기본키와 후보키가 결정자인가?

#### 완전 함수 종속 (1시간대 설명임 다시 듣기)
##### 개념
종속 속성이 기본키 전체에만 의존하고, 부분집합에는 의존하지 않는 경우
##### 예시
`(고객아이디, 이벤트번호) → 당첨여부`
##### 이유
- 당첨여부는 **고객아이디만으로도**, **이벤트번호만으로도** 결정 안 됨
- 두 개가 **모두 필요**해야 결정 가능

-> 완전 함수 종속✅

#### 부분 함수 종속 (1시간대 설명임 다시 듣기)
##### 개념

##### 예시

##### 이유


이건 집에서 더 공부하기
## 기본 정규형과 정규화 과정
제1정규형에서 → 5 :  중복↓ & 성능↓ 

==각 정규형마다 위반되는 경우를 파악해야 할듯==

그럼 정규형단계가 올라갈수록 전 단계 이상현상을 보완하며 올라간다는 건가?

각 릴레이션 그림을 보여주고 각 이상현상을 파악할줄 알야아한다 **기말고사** (1시간 16분대)
	-> 그림에 적힌 릴레이션 정규형을 파악하고 이상현상을 파악해야한다
	-> n정규형으로 분해했을때 발생하는 이상현상을 구분, 파악해야함

4정규형, 5정규형은 안배운다
### 제 1 정규형
#### 개념
릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있어야 함

#### 위반
속성을 1,2,3,4 ... 여러개 정의하는것도 위반

*정리 다 안해서 해야함*

#### 이상현상 발생
##### 삽입 이상상

##### 갱신 이상

##### 삭제 이상

*정리 다 안해서 해야함*

### 제 2 정규형
#### 개념
릴레이션이 제 1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제 2정규형에 속한다.
	-> 기본키 속성이 1개면 무조건 2정규형 만족
		대부분 릴레이션은 2정규형까지가 디폴트다..?
	-> 부분함수종속을 제거한다
![[Pasted image 20250526113248.png]]
![[Pasted image 20250526113305.png]]

#### 이상현상 발생
##### 삽입 이상상

##### 갱신 이상

##### 삭제 이상

*정리 다 안해서 해야함*

#### 무손실 분해
- 정보의 손실이 없게 분해하는것
- 역 정규화 해도 문제 없도록 하는것

### 제 3 정규형
#### 개념
릴레이션이 제 2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 **이행적 함수 종속이 되지 않으면** 
제 3정규형에 속한다.
![[Pasted image 20250526113147.png]]
![[Pasted image 20250526113208.png]]

#### 이상현상 발생
##### 삽입 이상상

##### 갱신 이상

##### 삭제 이상

*정리 다 안해서 해야함*


### 보이스/코드 정규형

#### 개념
릴레이션의 함수 종속 관계에서 **모든 결정자가 후보키이면** 보이스 / 코드 정규형에 속한다.


%%ㅈ됨 수업 1도 못들음%%


# 회복과 병행제어
트랜지션 기본상태를 공부한다

>동시(성) 병행수행
>	-> 다수의 사용자가 동시에 사용하도라도 정확한 데이터를 유지해야함 
>	
>회복
>	->DB에 장애가 발생하더라도 원리의 상태로 복구 할수 있어야 한다 
## 트랜젝션

### 개념
작업하나를 수행하는데 필요한 데이터베이스의 연산을 모아놓은 것

### 특성
트랜잭션이 성공적으로 처리되어 데이터베이스의 무결성과 일관성이 보장되려면 네 가지 특성 ==ACID특성==을 만족해야함

#### 원자성 (atomicity)
##### 개념
-  트랜잭션의 원자성은 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 ==all-or-nothing== 방식을 의미한다.
-  만약 트랜잭션을 수행하다가 장애가 발생하여 작업을 완료하지 못했다면, 지금까지 실행한 연산 처리를 모두 취소하고 **데이터베이스를 트랜잭션 작업 전의 상태로 되돌려 트랜잭션의 원자성을 보장해야 한다**. 
	=> 롤백 보장해줘야한다

#### 일관성 (consistency)
##### 개념
- 트랜잭션의 일관성은 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 함을 의미한다.
	-> 예약한도는 30명이라면 29명이 예약했을때 1명만 예약이 더 가능해야한다는거
	-> 만약 위에 경우에서 3명이 더 예약 가능해질 경우 일관성 깨짐

- 트랜잭션이 수행되는 과정에서는 **데이터베이스가 일시적으로 일관된 상태가 아닐 수 있지만** 트랜잭션의 수행이 성공적으로 완료된 후에는 데이터베이스가 일관된 상태를 유지해야 한다.
	-> 티켓팅할때 순간보일땐 자리남아보이지만 누르면 자리없다고 뜨는거랑 같은 개념

#### 격리성 (isolation)
##### 개념
- 트랜잭션의 격리성은 고립성이라고도 하는데, 현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없음을 의미한다.  ?
![[Pasted image 20250602103451.png]]
-> 5000 + 1000 이면 6000원이여야 하지만 5000원만 내용이 업데이트된 상태
	 ->둘다 반영이 되야하지만 둘중하나가 날라가는 경우 (위에 경우 1000원이 날라감)

- 일반 적으로 데이터베이스 시스템에서는 ==여러 트랜잭션이 동시에 수행되지만 각 트랜잭션이 독립적으로 수행될 수 있도록 다른 트랜잭션의 중간 연산 결과에 서로 접근하지 못하게 한다.==
	->lock을 건다는 뜻
![[Pasted image 20250602103725.png]]


##### 지속성 (durability)
##### 개념
- 트랜잭션의 지속성은 영속성이라고도 하는데 트랜잭션이 **성공적으로 완료된 후(commit)** 데이터베이스에 반영한 수행 결과는 ==어떠한 경우에도 손실되지 않고 영구적이어야 함==을 의미한다.
	->커밋후에는 어떤 때려죽일이 있어도 손실되지 않는다


==ACID는 회복과 관련된 얘기이다==

### 트랜잭션 연산



### 트랜잭션의 상태

#### ==부분완료==
- 연산의 처리가 끝났지만 트랜잭션이 수행된 최종 결과를 DB에 아직 반영하지 않은 상태
commit을 안한상태
- 그러면 부분완료상태에서 ACID특성을 지켜 완료되거나 실패가 된다?


## 장애와 회복
회복의 중요 키워드는 로그 데이터이다?
->회복은 로그를 이용한다 (어떤 트랜잭션 무슨 실행을 했다 남아 있음 (커밋 history같은건가?))
### 장애의 유형
트랜잭션 장애만 공부할 예정정
![[Pasted image 20250602111611.png]]

### 데이터베이스의 저장 연산
![[Pasted image 20250602111432.png]]
로그데이터는 안정저장장치에 저장한다

![[Pasted image 20250602112803.png]]
실제로 데이터를 가져오는건 중간에 메인 메모리가 조율한다?

커밋을 해도 디스크에 반영이 안되고 왜 메인메모리에만 반영이 되어 있나? (기말문제)
->속도 때문 (메모리 지역성 구조를 가지기 때문) 12-2 | 34분대

전원이 나갔을때 메인메모리에만 커밋되어 있어 디스크엔 반영이 안되어 있다면 어케되냐? (기말문제)
- 지속성이 깨진다?
- 로그데이터를 찾아 롤백한다 -> undo한다
- 완료된 데이터는 redo한다

커밋이 반영이 됬는데 왜 redo를 하냐? (기말문제)
- ==커밋을 했지만 내가 변경한 데이터가 디스크에 반영이 된거란 보장이 없기 때문==
	->반영안된 놈이 있을수도 있기 때문
- 모르겠는데? 일단 reod 조져 같은느낌?

회복관련된 얘기 12-2 | 43분대
- ==커밋이 있으면 redo, 커밋이 없으면 undo==